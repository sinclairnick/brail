import fs from "node:fs";
import path from "node:path";
import { camelCase } from "../../util/string.util";
import { BrailConfig } from "./types";

export type PageDir = {
  path: string;
  type: "dir";
  key: string;
  children: Page[];
};

export type PageFile = {
  type: "file";
  path: string;
  key: string;
};

export type Page = PageDir | PageFile;

const IGNORED_PATHS = [/^api$/, /^_app$/, /^_document$/, /^_error$/];

export const isIgnored = (fname: string) => {
  return IGNORED_PATHS.some((x) => x.test(fname));
};

export const isValidExtension = (ext: string, extensions: string[]) => {
  return extensions.includes(ext);
};

export const stripExt = (path: string, exts: string[]) => {
  return exts.reduce((acc, ext) => acc.replace(`.${ext}`, ""), path);
};

export const stripLeadingSlash = (path: string) => {
  return path.replace(/\/([a-zA-Z0-9]+)/, "$1");
};

export const extractFileParts = (path: string) => {
  const [_, fname, ext] = /^([\w\s-]+)\.?([\.\w]+)?$/.exec(path) ?? [];
  return { fname, ext };
};

const GENERATED_FILE_WARNING =
  `// ⚠️ Warning: This file was automatically generated by \`brail\`.\n` +
  `// Any changes you make to this file will be overwritten.\n\n` +
  `// If you wish to make changes, you can manually import templates into another file and use that "template map".\n` +
  `// You can turn this auto-generation off via the \`emitTemplates\` option in your next/brail config.\n\n`;

export const getTemplatePages = (
  cwd: string,
  config: Pick<BrailConfig, "templateExtensions">
): Page[] => {
  const pages: Page[] = [];

  const files = fs.readdirSync(cwd);

  for (const file of files) {
    const fpath = path.join(cwd, file);
    const isDir = fs.statSync(fpath).isDirectory();
    const { ext, fname } = extractFileParts(file);
    const key = camelCase(fname);

    if (isDir) {
      if (isIgnored(file)) continue;

      pages.push({
        path: fpath,
        type: "dir",
        key,
        children: getTemplatePages(fpath, config),
      });

      continue;
    }

    if (isIgnored(fname)) continue;
    if (!isValidExtension(ext, config.templateExtensions)) continue;

    pages.push({ type: "file", path: fpath, key });
  }
  return pages;
};

class TemplateImportMap {
  private imports: string[] = [];
  private templateMap: Record<string, string> = {};

  addImport(cwd: string, page: PageFile) {
    const cleanPath = path.relative(cwd, page.path).replace(/\.[j|t]sx?/, "");
    this.imports.push(`import ${page.key} from "${cleanPath}"`);
  }

  private importsStr(): string {
    return this.imports.join(";\n");
  }

  addTemplate(page: PageFile) {
    this.templateMap[page.key] = page.key;
  }

  addTemplateMap(key: string, value: TemplateImportMap, depth: number) {
    this.templateMap[key] = value.templateString(key, depth);
    this.imports.push(...value.imports);
  }

  private templateString(key?: string, depth: number = 1): string {
    const z = "  ".repeat(depth + 1);
    const zz = "  ".repeat(depth + 2);

    const core = Object.values(this.templateMap).join(",\n" + zz);

    if (key == null) return core;

    return `{\n` + `${z}${key}: {\n` + `${zz}${core}\n` + `${z}}` + `\n}`;
  }

  fileString() {
    const str =
      GENERATED_FILE_WARNING +
      `${this.importsStr()};\n\n` +
      `export const templates = ${this.templateString()}\n`;
    return str;
  }
}

export const pageListToStr = (
  cwd: string,
  pages: Page[],
  depth = 1
): TemplateImportMap => {
  const map = new TemplateImportMap();

  for (const page of pages) {
    if (page.type === "dir") {
      map.addTemplateMap(
        page.key,
        pageListToStr(cwd, page.children, depth + 1),
        depth
      );
      continue;
    }

    map.addImport(cwd, page);
    map.addTemplate(page);
  }

  return map;
};
